# KFX フォーマット仕様（推定）

本書は calibre 用 KFX Input プラグインのソースコードを解析し、KFX コンテナの内部構造を推定した仕様書である。Kindle 公式仕様ではなく、プラグインの挙動から得られた情報に基づいている点に留意されたい。

## 1. コンテナ全体構造

### 1.0 シンボル ID の意味

本仕様書に登場する「シンボル ID」は、Amazon Ion バイナリフォーマットで利用されるシンボルテーブル上の数値識別子を指す。Ion では構造体のキーが整数 ID で格納され、同一コンテナ内の `$ion_symbol_table`（および Amazon のシステムシンボル表）によって ID と文字列の対応付けが行われる。したがって `$409` 等の表記は Ion が内部で使う数値 ID であり、プラグインコードの定数名ではない。Ion バイナリ値は TLV（type-length-value）形式で表され、それぞれの値の長さは Ion 自身が埋め込む可変長サイズフィールドによって決定される。

### 1.1 ヘッダー概要

KFX ファイルは `"CONT"` という 4 バイトのシグネチャを持つコンテナであり、既定バージョンは 2（互換バージョン 1〜2）である。ヘッダー最小長は 18 バイト、推奨チャンクサイズは 4096 バイト、コンテナの最大長は 16 MiB と定義されている。

- 0x00–0x03: シグネチャ `"CONT"`
- 0x04–0x05: バージョン（16 ビット little-endian。既定値 2、許容値 {1,2}）
- 0x06–0x09: ヘッダー長 `header_len`（32 ビット little-endian。最小 18 バイト）
- 0x0A–0x0D: コンテナ情報オフセット（32 ビット little-endian。ファイル先頭からの Ion 構造体開始位置）
- 0x0E–0x11: コンテナ情報長（32 ビット little-endian。Ion 構造体のバイト数）

以降 `header_len` までの領域がヘッダーとみなされ、それより後ろがエンティティデータ領域となる。

### 1.2 コンテナ情報 Ion

コンテナ情報は IonBinary 形式の構造体で、次のフィールドが定義される。各フィールドの値は Ion の長さフィールドに従って取り出す。

| シンボル ID | 意味 | 備考 |
| --- | --- | --- |
| `$409` | コンテナ ID（ACR） | Ion string。`kfxgen_acr` と照合される |
| `$410` | 圧縮方式 ID | Ion int。既定値 0（非圧縮）。異なる場合は警告 |
| `$411` | DRM スキーム ID | Ion int。既定値 0（DRM なし） |
| `$412` | チャンクサイズ | Ion int。既定値 4096 |
| `$413` / `$414` | エンティティ索引テーブルの開始位置とサイズ | Ion int。値はそれぞれファイル先頭からのオフセット（バイト）とテーブル長（バイト）。オフセットは Ion セクションではなくヘッダー全体を基準に算出される |
| `$415` / `$416` | 文書シンボル表の位置と長さ | Ion int。`$416` で示す長さ分を `$415` のオフセットから取得し、Ion 注釈 `$ion_symbol_table` として解釈 |
| `$594` / `$595` | フォーマット機能ブロックの位置と長さ | Ion int。コンテナバージョン > 1 の場合に出現し、注釈 `$593` を持つ Ion 値 |

Ion 構造体からフィールドを読み出した際に未消費の値が残った場合は異常とみなされる。

コンテナヘッダーから抽出した情報は、プラグイン内部で `$270` フラグメントとして再構成される。このとき次の派生フィールドが付加される。

| シンボル ID | 意味 | 備考 |
| --- | --- | --- |
| `$161` | コンテナ種別 | 収録フラグメントに応じて `"KFX main"`／`"KFX metadata"`／`"KFX attachable"` の文字列を選択 |
| `$181` | コンテナエンティティ一覧 | `[type_id, id_id]` の配列。エンティティ索引テーブルから再現 |
| `$587` | kfxgen アプリケーションバージョン | ヘッダー末尾の `kfxgen` 情報を Ion 化した値 |
| `$588` | kfxgen パッケージバージョン | 同上 |
| `version` | コンテナバージョン | ヘッダーに記録された 16 ビット値 |

### 1.3 エンティティ索引テーブルと kfxgen 情報

`$413/$414` で指し示されるエンティティ索引テーブルは、24 バイト固定長のエントリが連続したバイト列である。エントリの構造は `<L`（エンティティ ID のシンボル ID）、`<L`（フラグメント型のシンボル ID）、`<Q`（エンティティデータのオフセット）、`<Q`（エンティティデータの長さ）で、いずれも little-endian。オフセットは `header_len` の位置を基準としたエンティティデータ領域内のバイト位置であり、長さは該当エンティティのバイト数を表す。

コンテナ情報領域の直後から `header_len` までの未使用領域には、`key:`／`value:` 形式の ASCII テキストが挿入され、`kfxgen_package_version` や `kfxgen_payload_sha1` などのメタデータを保持する。このテキストは JSON に整形して扱う。

### 1.4 ドキュメントシンボル表

`$415/$416` が示す領域には Ion 注釈 `$ion_symbol_table` を持つシンボル表が格納される。プラグインは読み込み時に Amazon のシステムシンボル表を差し引き、内部シンボルテーブルへ登録する。シリアライズ時は逆に再加算してエクスポートする。

### 1.5 フォーマット機能ブロック

バージョン 2 以降のコンテナでは、任意で `$593` 注釈を持つフォーマット機能 Ion を格納できる。機能ブロックはシンボルテーブルのローカル ID が 595 より大きい場合にのみ書き戻される。

### 1.6 kfxgen 情報ストリーム

ヘッダーの末尾から本体データまでの領域に格納された `key:`/`value:` 形式テキストは、アプリケーションバージョン・パッケージバージョン・ペイロード SHA-1・ACR を記録する。テキスト長は Ion とは無関係で、`header_len` で示された位置がテキストの終端である。

テキストは Ion ではなく JSON の簡易表現で、`0x1B`（ESC）を除去した後に `"key"`／`"value"` キーへ整形することで辞書配列として解釈できる。典型的なエントリは以下の通り。

| key | value |
| --- | --- |
| `kfxgen_package_version` / `buildVersion` | KFX 生成パッケージのバージョン |
| `kfxgen_application_version` / `appVersion` | 生成元アプリケーションのバージョン |
| `kfxgen_payload_sha1` | エンティティデータ領域（`header_len` 以降）の SHA-1 ハッシュ |
| `kfxgen_acr` | `$409` で定義されたコンテナ ID と一致する文字列 |

未知のキーが記録されている場合、プラグインは警告を発する。SHA-1 値や ACR が一致しない場合も検出される。

## 2. コンテナエンティティ

各フラグメントはエンティティとして格納される。エンティティは `"ENTY"` シグネチャとバージョン 1 を持つヘッダーを備え、ヘッダー部は次のように構成される。

- 0x00–0x03: シグネチャ `"ENTY"`
- 0x04–0x05: バージョン（16 ビット little-endian。許容値 {1}）
- 0x06–0x09: ヘッダー長（32 ビット little-endian。最小 10 バイト）
- 0x0A–: Ion 構造体（`$410` と `$411` を保持）

ヘッダー Ion は IonBinary 形式で格納され、`$410`（圧縮方式 ID）と `$411`（DRM スキーム ID）の 2 フィールドを持つ。いずれも Ion int で、既定値は 0。Ion の長さフィールドによりヘッダー長が決定される。`header_len` で示された位置以降がフラグメント本体のデータ領域であり、そのサイズは前節のエンティティ索引テーブルで取得する。

フラグメントの型シンボルが `$418` または `$417` の場合はバイナリ BLOB として格納され、それ以外は IonBinary で Ion 値として解釈される。エンティティには ID（`$348` 注釈で匿名 ID を示す場合あり）とフラグメント型のシンボル ID が添付され、コンテナ情報のエンティティ一覧 (`$181`) にも `[type_id, id_id]` の並びで登録される。

DRM が有効化されている場合、エンティティデータは `\xeaDRMION\xee` という 8 バイトのシグネチャを持つ Ion BLOB でラップされる。DRM 無しのファイルではこのシグネチャ自体が現れない。

## 3. フラグメント体系

KFX は Ion 注釈を利用して「フラグメント」と呼ばれる論理単位を管理する。プラグインは既知のフラグメント型とその並び順、必須／任意要素を以下のように定義している。

### 3.1 フラグメント型の優先順序

並べ替えや比較時に利用される優先順序は次の通り。

```
$ion_symbol_table, $270, $593, $585, $490, $258, $538, $389, $390,
$260, $259, $608, $145, $756, $692, $157,
$391, $266, $394,
$264, $265, $550, $609, $621, $611, $610,
$597, $267, $387,
$395,
$262, $164,
$418, $417,
$419
```

### 3.2 ルートおよび単一出現フラグメント

ルートフラグメント（コンテナ直下に現れる）の型と、その中で単一出現が期待されるものは以下の通りである。

| カテゴリー | フラグメント型 |
| --- | --- |
| ルート | `$ion_symbol_table`, `$270`, `$490`, `$389`, `$419`, `$585`, `$538`, `$262`, `$593`, `$550`, `$258`, `$265`, `$264`, `$395`, `$390`, `$621`, `$611` |
| 単一出現 | 上記ルート集合から `$270`, `$262`, `$593` を除いたもの（1 つのみ存在が期待される） |

### 3.3 必須および許容フラグメント

| 種別 | フラグメント型 |
| --- | --- |
| 必須 | `$ion_symbol_table`, `$270`, `$490`, `$389`, `$419`, `$538`, `$550`, `$258`, `$265`, `$264`, `$611` |
| 任意 | `$266`, `$597`, `$418`, `$417`, `$394`, `$145`, `$585`, `$610`, `$164`, `$262`, `$593`, `$391`, `$692`, `$387`, `$395`, `$756`, `$260`, `$267`, `$390`, `$609`, `$259`, `$608`, `$157`, `$621` |

### 3.4 フラグメント ID の決定

特定のフラグメント型は内部フィールド値で識別子（`fid`）を導出する。例えば `$266` はフィールド `$180`、`$145` は `name` フィールドを ID として用いる。ID 判定に利用されるフィールド一覧を次表に示す。

| フラグメント型 | 照キー |
| --- | --- |
| `$266` | `$180` |
| `$597` | `$174`, `$598` |
| `$418`/`$417` | `$165` |
| `$394` | `$240` |
| `$145` | `name` |
| `$164` | `$175` |
| `$391` | `$239` |
| `$692` | `name` |
| `$387` | `$174` |
| `$756` | `$757` |
| `$260`/`$267`/`$609` | `$174` |
| `$259` | `$176` |
| `$608` | `$598` |
| `$157` | `$173` |
| `$610` | `$602` |

### 3.5 フラグメント間参照

多くの Ion 構造は他フラグメントを参照するシンボルフィールドを持つ。プラグインが把握している代表的な参照先は以下の通り。

- `$749` → `$259`（目次リンクなど）
- `$165`/`$636` → `$417`（リソース参照）
- `$479`/`$245`/`$167`/`$175`/`$528`/`$214`/`$635` → `$164`
- `$392` → `$391`、`$174`/`$170` → `$260`、`$176` → `$259`

辞書や入れ子構造向けの特別ルール（`$391`→`$394` など）も定義されている。

## 4. シンボルテーブル

### 4.1 システムシンボル表

Ion 自体が提供するシステムシンボル表 `$ion` はバージョン 1 で、`$ion_symbol_table` や `name` といった Ion 共通キーを含む。KFX ではこれに加えて Amazon 固有の共有シンボル表がインポートされる。

### 4.2 YJ シンボル表

KFX コンテナには `YJ_symbols` という共有シンボル表（バージョン 10）が登場することがあり、Ion のインポート宣言で `$ion_symbol_table` に連結される。表の中身は `$10`〜`$757` のような仮ラベルで、Ion のローカル ID と Kindle 内部シンボル名の対応を定義する。プラグインはこの表を既知の辞書として保持し、インポート時に `max_id` を参照しながらローカルシンボルと共有シンボルを切り分ける。`YJ_symbols` を観測した場合は、Ion 値に現れる数値 ID をこのテーブルに従って解決する必要がある。

### 4.3 ドキュメントシンボル表

`$415/$416` で示されるローカルシンボル表は、`imports` 配列で `SYSTEM_SYMBOL_TABLE`（`$ion`）と `YJ_symbols` を参照したうえで、書籍固有のシンボルを `symbols` 配列に定義する。`max_id` を持つインポートでは、プラグインがシステム表のエントリ数を差し引いて Kindle 側の ID 空間と同期させる。書き戻し時は逆に `max_id` を再加算し、Ion 書式に合わせてローカルシンボルをシリアライズする。

## 5. メタデータ

メタデータは主に `$490` フラグメントの `$491` 構造、および `$258` フラグメントのキー/値マップで管理される。既知のメタデータキーとシンボル ID の対応は次の通り。

| 人間可読キー | シンボル ID |
| --- | --- |
| ASIN | `$224` |
| asset_id | `$466` |
| author | `$222` |
| cde_content_type | `$251` |
| cover_image | `$424` |
| description | `$154` |
| language | `$10` |
| orientation | `$215` |
| publisher | `$232` |
| reading_orders | `$169` |
| support_landscape | `$218` |
| support_portrait | `$217` |
| title | `$153` |

`$490` 内の `kindle_title_metadata` コレクションでは、キー `author`／`title`／`ASIN` 等を個別のレコードとして保持する。`$258` には冗長な情報が残っていることがあり、`author` フィールドは複数著者を文字列から分割して構築する処理が含まれている。

メタデータ書き込み時には既存値の差し替えやカバー画像の再エンコード（JPEG 形式の検証）を行い、必要に応じて ASIN を自動生成するロジックも存在する。

## 6. データ型と Ion 表現

KFX の論理データは Amazon Ion 形式で表現される。Ion は JSON に類似した構造化バイナリで、シンボルテーブルによる識別子管理を行う。

- Ion の基本型は bool、decimal、float、int、list、null、string 等。
- `IonAnnotation` は Ion 値に対し 1 つ以上のシンボル注釈を付与する。フラグメントは `fid` と `ftype` の 2 注釈を持つ。
- バイナリデータは `IonBLOB` として扱われ、ASCII で解釈できない場合は大型データとして判定される。
- `IonStruct` は順序付きマップであり、偶数個の引数を `キー, 値` のペアとして受け取る。
- `IonSymbol` はシンボルテーブル内の文字列を表し、ASCII 範囲外はバッククォート表記で表示される。

## 7. フォーマット識別と派生形式

コンテナ内に含まれるフラグメント型の ID 番号を調べ、`$259`/`$260`/`$538` を含む場合は「KFX main」、`$258`/`$419`/`$490`/`$585` などメタデータ主体の場合は「KFX metadata」、`$417` のみの場合は「KFX attachable」と判定する。

DRM 付き Ion ブロックは `"\xeaDRMION\xee"` で始まることがあるが、既定状態では DRM スキーム 0 が想定される。

## 8. 画像とリソース

画像リソースはチェック対象フォーマット（BMP, GIF, JPEG, PNG, SVG, TIFF, WEBP 等）と未チェックフォーマット（JXR, KVG）に分類される。固定レイアウトの画像形式は `$286` などのシンボルで示される。リソース参照は `$165`（および `$636`）のフィールドから `$417` フラグメントを指す。

## 9. セクションデータと期待される注釈

テキストやレイアウト断片（`$387`, `$260`, `$267`, `$609`）はセクションデータとして扱われ、特定の注釈組み合わせ（例: `$389::$247::$393`）が期待される。辞書コンテンツではさらに `$260::$141::$608` のような注釈が想定される。

## 10. シンボル分類

プラグインはシンボルを *common*（共通）, *dictionary*（辞書用）, *original*（元書籍由来）, *base64*, *short*, *shared*, *unknown* といったカテゴリーに分類し、解析時の診断情報に用いている。

## 11. 注意事項

- 本仕様はプラグイン実装に基づく推定であり、Amazon が公式に公開する仕様とは異なる可能性がある。
- DRM が適用されたコンテナでは Ion データが暗号化されるため、本仕様のままでは解読できない。
- Ion シンボル ID（`$xxx`）はシンボルテーブルに依存するため、別のコンテナでは異なる名称が割り当てられる可能性がある。

*出典: calibre KFX Input プラグイン（John Howell, 2016-2025）*
